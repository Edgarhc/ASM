package com.asm.widget.codeedit;

import android.graphics.*;
import android.text.*;
import android.util.*;
import com.asm.annotation.*;
import java.io.*;
import java.util.regex.*;
import android.os.*;


/**
 * Storage text and highlight data for ScrollingEditText.
 * Supports feature that text storage.
 * Also features for editing.
 */
public class TextData implements Editable, Serializable
{
	/**
	 * @hide
	 * A cache for less legging.
	 */
	public static class Cache
	{
		/** log tag */
		private static final String TAG = "TextData.Cache";
		
		/** parent {@code TextData}. */
		transient public TextData data;
		
		/** cursor positions. */
		public int cursorPosition;
		
		/** cursor positions. */
		transient public int cursorLine, cursorCol, cursorEnd;
		
		/** all lines count */
		transient public int lines = 1;
		
		/** shows whether line count is old or not. */
		transient private boolean isLineCountOlds = true, isWidthOlds = true, isHeightOlds = true;
		
		/** cache */
		transient private int scrollableWidth;
		
		/** cache */
		transient private int scrollableHeight;
		
		
		public Cache(@NonNull TextData data) {
			this.data = data;
		}
		
		/** called before insert text to update cache */
		public void onInsert(int where, CharSequence text, int start, int end) {
			if(isLineCountOlds) updateIfNeeded();
			int newLineCount = TextUtils.countOf(String.valueOf(text.subSequence(start, end)), "\n", 0);
			lines += newLineCount;
			
			if(cursorPosition >= where) {
				addCursorPosition(end - start + 1);
			}
			isWidthOlds = true;
		}
		
		/** called before delete text to update cache */
		public void onDelete(int start, int end) {
			if(isLineCountOlds) updateIfNeeded();
			int subtractLineCount = TextUtils.countOf(data.substring(start, end), "\n", 0);
			lines -= subtractLineCount;
			
			if(cursorPosition > end) {
				addCursorPosition(-(end - start + 1));
			} else if(cursorPosition > start) {
				setCursorPosition(start);
			}
			isWidthOlds = true;
		}
		
		/** move cursor position */
		public void addCursorPosition(int add) {
			int newPosition = Math.max(0, Math.min(add + cursorPosition, data.length() - 1));
			int newLineCount = TextUtils.countOf(data.substring(newPosition, cursorPosition), "\n", 0);
			if(add > 0) cursorLine += newLineCount;
			else cursorLine -=  newLineCount;
			int addCol = data.lastIndexOf("\n", newPosition);
			if(addCol == -1) cursorCol = newPosition;
			else cursorCol += addCol;
			cursorPosition += add;
		}
		
		/** set cursof position */
		public void setCursorPosition(int pos) {
			addCursorPosition(pos - cursorPosition);
		}
		
		/** update width / height if needed. */
		public void updateIfNeeded() {
			if(isWidthOlds) updateScrollableSize();
			else if(isHeightOlds) lines();
		}
		
		/** update width AND height if needed. */
		public void updateBothIfNeeded() {
			if(isWidthOlds || isHeightOlds) updateScrollableSize();
		}
		
		/** update width and height. */
		public void updateScrollableSize() {
			//Log.d(TAG, "updateScrollableSize()");
			if(data.draw == null) return;
			//Log.d(TAG, "data.draw non null");
			int lineCount = 1;
			float curW = 1;
			int maxW = 20;
			for(int i = 0; i < data.length(); i++) {
				if(data.charAt(i) == '\n') {
					if(maxW < curW) maxW = (int) curW;
					curW = 0;
					lineCount++;
				} else {
					curW += data.draw.getPaint().measureText(new char[]{data.charAt(i)}, 0, 1);
				}
			}
			this.scrollableWidth = maxW;
			this.scrollableHeight = (int) (lineCount * data.draw.getLineSpacing());
			this.lines = lineCount;
			this.isWidthOlds = false;
			this.isHeightOlds = false;
			this.isLineCountOlds = false;
			//Log.d(TAG, "result " + scrollableWidth + " X " + scrollableHeight + ", lines " + lines);
		}
		
		/** update if needed and return scrollable width */
		public int getScrollableWidth() {
			if(isWidthOlds) updateScrollableSize();
			return scrollableWidth;
		}
		
		/** update if needed and return scrollable height. */
		public int getScrollableHeight() {
			if(isHeightOlds) lines();
			return scrollableHeight;
		}
		
		/** update if needed and return line count. */
		public int lines() {
			//Log.d(TAG, "lines() " + isLineCountOlds + "," + (data.draw == null));
			if(isLineCountOlds) {
				lines = data.countOf("\n");
				//Log.d(TAG, "count lines " + lines);
			}
			isLineCountOlds = false;
			if(data.draw != null) {
				scrollableHeight = (int) (lines * data.draw.getLineSpacing());
				isWidthOlds = false;
				//Log.d(TAG, "data.draw non null");
			}
			//Log.d(TAG, "lines() end");
			return lines;
		}
		
		/**
		* return the first text forward position of line.
		* You can type startLine and startPos with start
		* position to calculate it.
		*/
		public int getLinePosition(int lines, int startPos, int startLine) {
			if(startPos < 0 || startPos >= data.length()) throw new IllegalArgumentException("startPos overed index");
			if(startLine > lines) throw new IllegalArgumentException("startLine overed lines");
			int linesCur = startLine;
			for(int i = startPos; i < data.length(); i++) {
				if(linesCur == lines) return i;
				if(data.charAt(i) == '\n') linesCur++;
			}
			return -1;
		}
	}
	
	/** position data when returns to {@code getPositionData}. */
	public static class PositionData
	{
		public int position;
		public int line, col;
		public float x, y;
		
		
		public PositionData() {}
		
		public PositionData(int p, int l, int c, float x, float y) {
			position = p;
			line = l;
			col = c;
			this.x = x;
			this.y = y;
		}
	}
	
	
	/** tag for Log. */
	private static final String TAG = "TextData";
	
	/** the main string storage builder. */
	StringBuilder str;
	
	/** undo manager for undo/redo. */
	private UndoManager undoManager;
	
	/** save manager for save when exit */
	transient private SaveManager saveManager;
	
	/** for more faster calculate. */
	transient private @NonNull Cache cache;
	
	/** default encoding. */
	String encoding = "UTF-16"; //TODO
	
	/** parent text drawing method. */
	transient TextDraw draw;
	
	
	private TextData() {
		str = new StringBuilder();
		init();
	}
	
	private TextData(CharSequence initValue) {
		str = new StringBuilder();
		init();
		str.append(initValue);
	}
	
	private TextData(StringBuilder b) {
		str = b;
		init();
	}
	
	private void init() {
		cache = new Cache(this);
		undoManager = new UndoManager();
		initSecondary();
	}
	
	private void initSecondary() {
		cache.updateScrollableSize();
		//cache.lines();
	}
	
	/** set all datas from other. */
	public void set(TextData other) {
		this.cache = other.cache;
		this.str = other.str;
		this.encoding = other.encoding;
		initSecondary();
	}
	
	//draw calculate methods
	
	/**
	 * Return the scrollable width.
	 * User can scroll content x from 0 to
	 * return value of this.
	 */
	public int getScrollableWidth() {
		return cache.getScrollableWidth();
	}
	
	/**
	 * Return the scrollable height.
	 * As same as <code>lines() * getDraw().getLineSpacing()</code>.
	 */
	public int getScrollableHeight() {
		return cache.getScrollableHeight();
	}
	
	/**
	 * Return the cursor's line count.
	 */
	public int getCursorLines() {
		return cache.cursorLine;
	}
	
	/**
	 * Return the cursor's column, count start from each line's head.
	 */
	public int getCursorCols() {
		return cache.cursorCol;
	}
	
	/**
	 * Return the cursor's position start from first charactor.
	 */
	public int getCursorPosition() {
		return cache.cursorPosition;
	}
	
	/**
	 * move the cursor position.
	 */
	public void setCursorPosition(int pos) {
		cache.setCursorPosition(pos);
	}
	
	/**
	 * move the cursor position.
	 */
	public void addCursorPosition(int add) {
		cache.addCursorPosition(add);
	}
	
	/**
	 * Set the drawing method {@code TextDraw}.
	 * if using {@code CodeEdit}, it will be called automatic.
	 */
	public void setDraw(TextDraw draw) {
		this.draw = draw; cache.updateIfNeeded();
	}
	
	/**
	 * return the {@code TextDraw}.
	 */
	public TextDraw getDraw() {
		return draw;
	}
	
	/** {@hide} */
	public Cache getCache() { return cache; }
	
	//text methods.
	
	/**
	 * Return the line count. 
	 */
	public int lines() {
		return cache.lines();
	}
	
	/**
	 * Returns the position of the line and col 0.
	 * @param lines line number that eant to get position
	 * @return the index start from first charactor, or return -1 when failed.
	 */
	public int getLinePosition(int lines) {
		return cache.getLinePosition(lines, 0, 0);
	}
	
	/**
	 * Returns the position of the line and col 0.
	 * @param lines line number that eant to get position
	 * @param startPos start position that measure lines.
	 * @param startLine start line index that start to search
	 * @return the index start from first charactor, or return -1 when failed.
	 */
	public int getLinePosition(int lines, int startPos, int startLine) {
		return cache.getLinePosition(lines, startPos, startLine); 
	}
	
	/**
	 * Returns the lines and cols of position.
	 * @return <code>int[] { lines, cols, x, y }</code>.
	 */
	public PositionData getPositionData(int position) {
		return getPositionData(position, 1, 0);
	}
	
	/**
	 * Returns the lines and cols of position.
	 * @return <code>int[] { lines, cols, x, y }</code>.
	 */
	public PositionData getPositionData(int position, int startLine, int startPos) {
		if(position > str.length()) throw new IllegalArgumentException("position is bigger than length");
		if(startPos > str.length()) throw new IllegalArgumentException("startPos is bigger than length");
		
		int lines = startLine;
		int lastLinePos = 0;
		int curPos = startPos;
		float x = 0;
		while(curPos <= position) {
			if(str.charAt(curPos) == '\n') {
				lines++;
				lastLinePos = curPos;
				x = 0;
			}
			x += draw.getPaint().measureText(new char[] {str.charAt(curPos)}, 0, 1);
			curPos++;
		}
		
		return new PositionData(position, lines, curPos - lastLinePos, x, lines * draw.getLineSpacing() - draw.getLineMargin());
	}
	
	
	//text data methods
	
	/**
	* insert the text at <code>where</code>.
	*/
	public TextData insert(int where, char text) { return insert(where, String.valueOf(new char[]{text}), 0, 1); }
	
	/**
	* insert the text at <code>where</code>.
	*/
	@Override public TextData insert(int where, CharSequence text) { return insert(where, text, 0, text.length()); }
	
	/**
	 * insert the text at <code>where</code>, from <code>start</code> to <code>end</code>. 
	 */
	public TextData insert(int where, CharSequence text, int start, int end) {
		//mind that text is not inserted now!
		cache.onInsert(where, text, end, start);
		str.insert(where, text, start, end);
		//after text inserted
		return this;
	}
	
	/** 
	 * return the string from <code>start</code> to <code>end</code>. 
	 */
	public String substring(int start, int end) {
		return str.substring(start, end);
	}
	
	/** 
	 * index of <code>text</code> in this text. 
	 */
	public int indexOf(String text) { 
		return str.indexOf(text); 
	}
	
	/**
	 * index of <code>text</code> in this text, start from <code>fromIndex</code>. 
	 */
	public int indexOf(String text, int fromIndex) { 
		return str.indexOf(text, fromIndex); 
	}
	
	/** 
	 * index of <code>text</code> from <code>fromIndex</code> to <code>endIndex</code>. 
	 * same as <code>substring(startIndex, endIndex).indexOf(text)</code> but more faster.
	 */
	public int indexOf(String text, int fromindex, int endIndex) { 
		return TextUtils.indexOf(str, text, fromindex, endIndex);
	}
	
	/**
	 * last index of <code>text</code>. 
	 */
	public int lastIndexOf(String text) {
		return str.lastIndexOf(text);
	}
	
	/** 
	* last index of <code>text</code>. 
	*/
	public int lastIndexOf(String text, int fromIndex) {
		return str.lastIndexOf(text, fromIndex);
	}
	
	/**
	 * last index of text from to limit.
	 * same as substring(limit, fromIndex).lastIndexOf(text) but faster.
	 */
	public int lastIndexOf(String text, int fromIndex, int limit) {
		return TextUtils.lastIndexOf(str, text, fromIndex, limit);
	}
	
	/**
	 * Check this text is matches to regex.
	 * @see Pattern
	 */
	public boolean matches(String regex) {
		return Pattern.matches(regex, str);
	}
	
	/** 
	 * return the count in this text witch equals target.
	 */
	public int countOf(String target) {
		return this.countOf(target, 0); 
	}
	
	/** 
	 * return the count in this text witch equals target.
	 */
	public int countOf(String target, int fromindex) {
		return TextUtils.countOf(str.toString(), target, fromindex, length());
	}
	
	/** 
	 * return the count in this text witch equals target.
	 */
	public int countOf(String target, int fromindex, int endIndex) {
		return TextUtils.countOf(str.toString(), target, fromindex, endIndex); 
	}
	
	
	
	/**
	 * convert {@code TextData} object to {@code String}.
	 */
	@Override
	public String toString() {
		return str.toString();
	}
	
	/**
	 * length of all texts.
	 */
	@Override
	public int length() {
		return str.length();
	}
	
	/**
	 * return character at position.
	 */
	@Override
	public char charAt(int position) {
		return str.charAt(position);
	}
	
	/**
	 * @see CharSequence.subString()
	 */
	@Override
	public CharSequence subSequence(int start, int end) {
		return str.subSequence(start, end);
	}
	
	/**
	 * same as <code>str.delete(st, en); str.insert(st, source, start, end);</code>
	 */
	@Override
	public TextData replace(int st, int en, CharSequence source, int start, int end) {
		delete(st, en);
		insert(st, source, start, end);
		return this;
	}
	
	/**
	 * same as <code>str.delete(st, en); str.insert(st, source, start, end);</code>
	 */
	@Override
	public TextData replace(int start, int end, CharSequence text) {
		replace(start, end, text, 0, text.length());
		return this;
	}
	
	/**
	 * delete the text, from start to end 
	 */
	@Override
	public TextData delete(int start, int end) {
		cache.onDelete(start, end);
		str.delete(start, end);
		return this;
	}
	
	/**
	 * Append text end of the text.
	 */
	@Override
	public TextData append(CharSequence text) {
		return append(text, 0, text.length() -1);
	}
	
	/**
	 * Append text cutted from start to end, end of the text.
	 */
	@Override
	public TextData append(CharSequence text, int start, int end){
		insert(str.length(), text, start, end);
		return this;
	}
	
	/**
	 * Append one charactor end of text.
	 */
	@Override
	public TextData append(char character) {
		return append(String.valueOf(new char[]{character}));
	}
	
	/**
	 * @see GetChars
	 */
	@Override
	public void getChars(int srcStart, int srcEnd, char[] dest, int dstBegin) {
		str.getChars(srcStart, srcEnd, dest, dstBegin);
	}
	
	/**
	 * clear all texts.
	 */
	@Override
	public void clear() {
		if(str.length() != 0) str.replace(0, str.length(), "");
	}
	
	
	/**
	 * unsupported: I'm lazy;;
	 * developer of this is saying that donno how to use it
	 * and supporting this will be complicated so not support.
	 * NOT SUPPORT..! <<hehe
	 *     ...
	 * ■		■	■■■■■
	 * ■		■	   ■
	 * ■		■	   ■
	 * ■■■■■■■	   ■
	 * ■		■	   ■
	 * ■		■	   ■
	 * ■		■	■■■■■
	 */
	
	/** not support yet */
	@Override public void setFilters(InputFilter[] p1) { throw new UnsupportedOperationException("너무 귀찮아요ㅠㅠ"); }
	
	/** not support yet */
	@Override public InputFilter[] getFilters() { throw new UnsupportedOperationException("너무 귀찮아요ㅠㅠ"); }
	
	
	//not support: CodeEdit automatically highlight
	
	/** not support: {@code CodeEdit} automatically highlight */
	@Deprecated public void clearSpans() { throw new UnsupportedOperationException(); }
	
	/** not support: {@code CodeEdit} automatically highlight */
	@Deprecated public void setSpan(Object p1, int p2, int p3, int p4) { throw new UnsupportedOperationException(); }
	
	/** not support: {@code CodeEdit} automatically highlight */
	@Deprecated public void removeSpan(Object p1) { throw new UnsupportedOperationException(); }
	
	/** not support: {@code CodeEdit} automatically highlight */
	@Deprecated public <T extends Object> T[] getSpans(int p1, int p2, Class<T> p3) { throw new UnsupportedOperationException(); }
	
	/** not support: {@code CodeEdit} automatically highlight */
	@Deprecated public int getSpanStart(Object p1) { throw new UnsupportedOperationException(); }
	
	/** not support: {@code CodeEdit} automatically highlight */
	@Deprecated public int getSpanEnd(Object p1) { throw new UnsupportedOperationException(); }
	
	/** not support: {@code CodeEdit} automatically highlight */
	@Deprecated public int getSpanFlags(Object p1) { throw new UnsupportedOperationException(); }
	
	/** not support: {@code CodeEdit} automatically highlight */
	@Deprecated public int nextSpanTransition(int p1, int p2, Class p3) { throw new UnsupportedOperationException(); }
	
	
	//static methods
	
	/**
	 * create empty TextData.
	 */
	public static TextData create() {
		return new TextData();
	}
	
	/**
	 * create TextData from texts.
	 */
	public static TextData valueOf(char[] text) {
		return new TextData(String.valueOf(text));
	}
	
	/** 
	 * create TextData from texts.
	 */
	public static TextData valueOf(CharSequence text) {
		return new TextData(text);
	}
	
	/**
	 * create TextData from {@code StringBuilder}.
	 */
	public static TextData from(StringBuilder builder) {
		return new TextData(builder);
	}
	
	/**
	 * Initialize {@code TextData} from a seriazed-object.
	 * When you got the {@code TextData} object from
	 * {@code ObjectInputStream} or other, you should
	 * initialize that object by this object.
	 * @params TextData what you want to convert
	 */
	public static TextData fromSerializable(Object data, TextDraw parent) {
		if(!(data instanceof TextData)) throw new IllegalArgumentException("argument is not a TextData");
		TextData data2 = (TextData) data;
		if(data2 == null) throw new IllegalArgumentException("argument is null");
		data2.draw = parent;
		data2.cache = new Cache(data2);
		data2.cache.updateScrollableSize();
		return data2;
	}
	
	/**
	 * create the TextData from parcel.
	 */
	public TextData fromParcel(Parcel p, TextDraw parent) {
		TextData d = new TextData();
		d.str = new StringBuilder(p.readInt());
		d.str.append(p.readString());
		undoManager = (UndoManager) p.readSerializable();
		d.encoding = p.readString();
		d.draw = parent;
		d.cache = new Cache(d);
		d.cache.updateScrollableSize();
		return d;
	}
	
	/**
	 * get the parcelable object.
	 */
	public Parcelable parcel() { return new TextDataParcel(); }
	
	/**
	* parcelable object for parcel.
	*/
	private class TextDataParcel implements Parcelable
	{
		@Override
		public int describeContents() {
			return 0;
		}
		
		/** 
		 * save all data to parcel.
		 */
		@Override
		public void writeToParcel(Parcel p, int flags) {
			p.writeInt(capacity);
			p.writeString(str.toString());
			p.writeSerializable(undoManager);
			p.writeString(encoding);
		}
	}
}
